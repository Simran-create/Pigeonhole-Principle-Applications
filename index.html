<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>How Infinity Hides into Your Algorithms</title>
  <style>
    body { max-width:900px; margin:auto; padding:20px;
           font-family:Segoe UI,Arial,sans-serif; color:#333; line-height:1.6; }
    nav { position:sticky; top:0; background:#fff; padding:10px 0;
          border-bottom:1px solid #ddd; margin-bottom:20px; }
    nav a { margin:0 12px; text-decoration:none; color:#0077cc; font-weight:500; }
    section { margin-bottom:50px; }
    h1,h2,h3 { color:#222; }
    h1 { font-size:2em; margin-bottom:0.2em; }
    h2 { font-size:1.6em; border-bottom:2px solid #eee; padding-bottom:0.2em; }
    .viz { text-align:center; margin:20px 0; }
    iframe { width:100%; height:400px; border:1px solid #ccc; border-radius:4px; }
    .callout { background:#f0f8ff; border-left:4px solid #66aaff;
               padding:12px; margin:20px 0; font-style:italic; }
  </style>

  <!-- MathJax configuration -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      chtml: { scale:1, minScale:1 }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>

  <h1>How Infinity Hides into Your Algorithms</h1>
  <nav>
    <a href="#intro">Introduction</a>
    <a href="#baby">The Baby PHP</a>
    <a href="#infinite">Infinite Applications</a>
    <a href="#cs">CS Uses</a>
    <a href="#proofs">Surprising Proofs</a>
    <a href="#art">The Art</a>
    <a href="#closing">Closing</a>
  </nav>

  <section id="intro">
    <h2>Introduction</h2>
    <p><em>â€œYou cannot put 10 socks in 9 drawers without something overlapping, obvious right? But this trivial fact lets you prove infinite truths, detect collisions in cryptography, and defeat compression algorithms.â€</em></p>
    <p>The Pigeonhole Principle (PHP)â€”â€œif you have more pigeons than holes, at least one hole must contain at least two pigeonsâ€â€”feels like kindergarten. Yet it powers:</p>
    <ul>
      <li>âœ–ï¸ Functions that <strong>fail to be injective</strong></li>
      <li>ğŸ—œï¸ Data files that <strong>canâ€™t be compressed</strong></li>
      <li>ğŸ” Cryptosystems that <strong>inevitably collide</strong></li>
      <li>â™¾ï¸ Infinite sets with <strong>no least member</strong></li>
    </ul>
  </section>

  <section id="baby">
    <h2>1. The Baby Pigeonhole Principle</h2>
    <h3>Formal Statement</h3>
    <p><strong>Pigeonhole Principle (finite version):</strong> Suppose n objects (pigeons) are distributed among m containers (holes). If n > m, then at least one container must contain at least two objects.</p>
    <p>Alternatively, if each container has at most one object, you can place at most m objects total. Once you place a (m + 1)th, you force a container to have two.</p>
    <h3>Visual Example</h3>
    <div class="viz"><iframe src="socks.html"></iframe></div>
    <h3>Birthday Paradox (Basic counting)</h3>
    <p><strong>Setup:</strong> Consider 23 people in a room. There are 365 possible birthdays.</p>
    <p><strong>Application of PHP:</strong> Since 23 < 365, the basic PHP does not force a collision. But if we has 366 people, two must share a birthday.</p>
    <p><strong>Remark.</strong> The â€birthday paradoxâ€ probability calculation shows that collisions happen much earlier than 366; but PHP gives a guarantee only when participants > 366.
     </p>
    <h3>Matching problems</h3>
    <p>If you have 5 red balls and 5 blue balls in 9 boxes, whatever arrangement, at least one box has at least 2 balls.</p>
    <p>More generally, distributing n items into k catagories forces at least $$
      \left\lceil \frac{n}{k} \right\rceil
      $$ items in one catagory.</p>
    <h3>Why this simple idea matters</h3>
    <li><strong>Universality.</strong> Any time you try to squeeze more objects into fewer â€œslots,â€ you get overlap.</li>
    <li><strong>Certainty.</strong> Unlike probabilistic arguments, PHP yields a strict, deterministic guarantee.</li>
    <li><strong>Foundation.</strong> Many elementary proofs (e.g., in combinatorics, graph theory, and number theory) rest on pigeonholes.</li>
  </section>

  <section id="infinite">
    <h2>2. Going Deeperâ€”Infinite Applications</h2>
    <p> While the finite PHP is easy, there are <strong>â€œinfiniteâ€</strong> analogues that let you extract surprising conclusions from seemingly weak assumptions.</p>.
    <h3>3.1 Infinite Pigeonhole Principle</h3>
    <p><strong>Infinite Pigeonhole Principle (Weak form)</strong>If infinitely many objects (pigeons) are distributed among finitely many categories (holes), then at least one category must contain infinitely many objects.</p>
    <p><strong>Why.</strong> Suppose you have infinitely many items x1, x2, x3,... and only m catagories. If each category held only finitely many, say at most Ni in catagory i, then the total objects would be at most N1 + N2 + ... +Nm < âˆ. That contradicts â€œinfinitely many.â€ Hence some category is infinite.</p>
    <p><strong>Diagram 1:</strong> Imagine we assign each natural number n âˆˆ N to one of 3 bins labeled A, B, C. If infinitely many numbers exist, one bin must collect infinitely many:</p>
    <p><strong>Bins:</strong>  [ A ],    [ B ],    [ C]</p>
    <p><strong>Numbers:</strong> 1â†’B 2â†’A 3â†’C 4â†’B 5â†’C 6â†’B 7â†’A 8â†’C 9â†’B ...</p>
    <p>Since there are infinitely many natural numbers, at least one bin, say B, receives infinitely many.</p>
    <div class="viz"><iframe src="bins.html"></iframe></div>
    <h3>3.2 Dirichletâ€™s Approximation</h3>
    <p><strong>Dirichletâ€™s Theorem.</strong></p>
    <p>For any real Î± and any integer N â‰¥ 1. there exist integers p and q with 1â‰¤ q â‰¤ N</p>
    <div class="callout">
      $$\bigl|\alpha - \tfrac{p}{q}\bigr| < \tfrac1{qN},\quad 1\le q\le N$$
    </div>
    <p>Sketch using pigeonholes.</p>
    <p>1. Consider the N + 1 real numbers $$
 \left|\, \alpha - \frac{p}{q} \right| \;\; < \;\; \frac{1}{q\,N}
 $$ where {x} denotes the fractional part of { x }. Each { kÎ± } lies in [0, 1).</p>
    <p>2. Partition the interval [0, 1) into N smaller half-open subintervals (â€œholesâ€): $$
[0,\tfrac{1}{N}), \;\; [\tfrac{1}{N},\tfrac{2}{N}), \;\dots,\; [\tfrac{N-1}{N},1).   $$</p>
    <p>By the (finite) PHP, two of the N + 1 fractional parts, say iÎ± and jÎ± with i < j â‰¤ N, must land in the same interval of length 1/N. Therefore,  $$
    \bigl| \{\,j\alpha\} - \{\,i\alpha\} \bigr| < \frac{1}{N}.  $$ </p>
    <p>But { jÎ±} âˆ’ { iÎ±} equals {(j âˆ’i)Î±} (up to possibly Â±1), so there is an integer q = j âˆ’i(1 â‰¤ q â‰¤ N) and integer p = âŒŠjÎ±âŒ‹ âˆ’ âŒŠiÎ±âŒ‹ such that $$
    \left|\, q\,\alpha - p \right| < \frac{1}{N}
    \quad\Longrightarrow\quad
    \left|\, \alpha - \frac{p}{q} \right| < \frac{1}{q\,N}.
    $$ 
    Thus infinite conclusionsâ€”approximation of irrationalsâ€”follow from partitioning a finite interval. </p>
    <h3>3.3 Irrationality of âˆš2</h3>
    <p>A classic proof of âˆš2 being irrational is not pigeonhole-style, but one can recast it via Dirichletâ€™s theorem:
    <ol><li>If âˆš2 = p/q exactly, then |âˆš2 âˆ’ p/q| = 0.</li>
        <li>But Dirichletâ€™s theorem guarantees infinitely many rational approximations p/q with $$
   \left| \sqrt{2} - \frac{p}{q} \right| < \frac{1}{q\,N}. $$  For large N, 1/qN < 0 is impossible, so no exact equality can hold.</li></ol></p>
    <p>This view shows that no rational can equal âˆš2, since rationals do not achieve these â€œtoo-goodâ€ approximations infinitely often.</p>
    <h3>3.4 Uncountability of the Real Numbers</h3>
      <p>While Cantorâ€™s diagonal argument is the most common proof, here is a pigeonhole-flavored reasoning: <ol>
        <li>Suppose for contradiction R is countable. List all real numbers in [0, 1] as r1, r2, r3, . . . .</li>
        <li> For each n, consider the decimal expansion of rn truncated at n digits. That is, let sn = first n digits of rn n [0, 1]. 
Each sn lies in one of the 10n intervals of the for $$\bigl[\,0.d_1 d_2 \dots d_n,\;0.d_1 d_2 \dots d_n + 10^{-n}\bigr).$$ </li>
        <li> For each n, assign rn to the â€œintervalâ€ corresponding to its truncated form sn. As n â†’ âˆ, we would be distributing infinitely many reals into 
             a <strong>strictly finite</strong> number of decimal-truncation intervals at each stageâ€”forcing some interval to contain infinitely many â€œtails.â€</li>
        <li> By a diagonal-type selection, you can then construct a real number not in your original list, contradicting countability. This is somewhat more involved than the standard diagonal, 
but it highlights how <strong>infinitely many pigeons (reals) into finitely many â€œdecimal-prefix slotsâ€</strong> forces a new real outside the enumeration</li>

      </ol></p>
      
  </section>

  <section id="cs">
    <h2>3. Pigeonholes in Algorithms and Computer Scienc</h2>
    <p>Modern computer science often exploits pigeonhole reasoning to show collisions, impossibility of lossless compression, and security bounds. Below are key applications</p>
    <h3>Hashing &amp; Collisions</h3>
    <p>If $n$-bit inputs map to $m$-bit outputs with $n>m$, collisions are forced.</p>
    <div class="viz"><iframe src="hash.html"></iframe></div>
    <h3>Compression Paradox</h3>
    <div class="callout">
      $$2^0+2^1+\dots+2^{L-1}=2^L-1$$
    </div>
  </section>

  <section id="proofs">
    <h2>4. Surprising Proofs</h2>
    <h3>ErdÅ‘sâ€“Szekeres</h3>
    <p>Sequence length $mn+1$ â‡’ inc.\ subseq.\ $m+1$ or dec.\ $n+1$.</p>
    <div class="viz"><iframe src="grid.html"></iframe></div>
    <h3>Ramsey in $K_6$</h3>
    <div class="viz"><iframe src="star.html"></iframe></div>
  </section>

  <section id="art">
    <h2>5. The Art of Finding the Right Pigeonholes</h2>
    <p>So far, weâ€™ve applied pigeonhole in rather straightforward waysâ€”grouping objects by obvious categories. In more advanced problems, 
      the creative insight is in designing the â€œholesâ€ so that the PHP yields a nontrivial conclusion.</p>
    <h3>5.1 The â€œDualityâ€ of Pigeonhole: Existence vs. Impossibility</h3>
    <p><li><strong>Existence proofs.</strong> Show that a certain structure must exist. Example: ErdËosâ€“Szekeres guarantees a long monotonic subsequence.</li>
    <li><strong>Impossibility proofs.</strong> Show that a certain algorithm or mapping cannot exist. Example: compression paradox, hashing injectivity.</li></p>
    <p>In both, you define a mapping (objects) â†’ (categories), and then count objects vs. categories.</p>
    <h3>5.2 Choosing Pigeonholes: Several Tips</h3>
    <ol>
      <li><strong>Map to a Finite Set.</strong> If you suspect an infinite conclusion (e.g., find infinitely many with some property), map infinitely many items to a finite set (e.g., basic types, intervals, residues modulo m).</li>
      <li><strong>Colors, Types, Intervals</strong>
      <uL>
        <li><strong>Colors. </strong>In graph theory or combinatorics, â€œcolorâ€ edges or vertices into a small number of classes.</li>
        <li><strong>Residue classes. </strong>In number theory, assign integers to {0,1,..., d-1} by taking remainders mod d.</li>
        <li><strong>Intervals. </strong>When dealing with real numbers, subdivide [0, 1] into intervals of length Îµ.</li>
      </uL></li>
      <li><strong>Look for Quantitative Bounds. </strong>If a problem asks to prove â€œsome subset of size k exists,â€ you often partition into fewer than k categoriesâ€”forcing a large class by PHP.</li>
      <li><strong>Symmetry Helps. </strong>When elements are exchangeable (e.g., vertices of a complete graph), you can assume one vertex is special and count its incident edges or neighbors.</li>
      <li><strong>Antichains and Chains. </strong>In partially ordered sets (posets), map each element to the length of the longest chain (or antichain) through it. Comparing lengths forces either a long chain or long antichain. This is the classic Dilworth/ErdËosâ€“Szekeres approach.</li>
    </ol>
  </section>

  <section id="closing">
    <h2>Closing</h2>
    <p>From â€œyou canâ€™t put 10 socks in 9 drawersâ€ to â€œno universal compressor can shrink every file,â€ the Pigeonhole Principle reveals astonishing power. By carefully choosing â€œholesâ€â€”intervals, residue classes, colors, or substructuresâ€”one transforms a <strong>finite counting argument</strong> into far-reaching conclusions.
    <li><strong>Infinite conclusions:</strong> Dirichletâ€™s approximation, uncountability, and existence of infinite subsets</li>
    <li><strong>Cryptographic bounds: </strong>collisions in hashing, birthday attacks in SHA, and security parameters.</li>
    <li><strong>Combinatorial certainties:</strong> monotonic subsequences, Ramsey-style triangles, and anticliques in posets</li>
    <li><strong>Impossibility theorems:</strong> compression paradox, injective limitations, and cache lower bounds</li>
    </p>
    <p>Every time you feel stuckâ€”when a problem hints at â€œtoo many items to fit in too few categoriesâ€â€”reach for the Pigeonhole Principle.</p>
    <p><strong>Call to Action. </strong>Next time you see â€œmore objects than categories,â€ pause. Can you define the categories (pigeonholes) so that PHP gives you exactly the statement you need? Look aroundâ€”every limitation hides a powerful truth waiting to be unearthed.</p>
    <h3>7.1 Further Exploration</h3>
    <p>If you want to dive deeper, consider these <strong>self-contained</strong> exercises:</p>
    <p><strong>1. Dirichletâ€™s Bound on Ï€.</strong> Show that there are infinitely many rational approximations p/q to Ï€ satisfying $$\left|\pi - \tfrac{p}{q}\right| < \tfrac{1}{q^2},$$ using a pigeonhole partition of {kÏ€} into intervals of length 1/N.</p>
    <p><strong>2. Ramsey Number R(4, 4).</strong> By extending the â€œstar-centerâ€ pigeonhole idea, prove that any 2-coloring of <code>K_18</code> contains a monochromatic K4. 
      (Hint: Partition edges incident to a vertex into two colors; then apply the R(3, 3) = 6 result on neighbors.)</p>

    <p><strong>3.Generalized PHP in Metric Spaces.</strong> Given infinitely many points in <code>[0, 1]^2</code>, partition the square into a nÃ—n grid of little squares. Show one small square contains infinitely many pointsâ€”yielding a cluster point for Bolzanoâ€“Weierstrass.</p>
    <blockquote>Each of these tasks reinforces the key insight: finite partitions force infinite structure.</blockquote>
    <p><strong>Remember:</strong> The simplest ideaâ€”â€œif more pigeons than holes, two share a holeâ€â€”is often the key to both elementary and deep mathematicalâ€”and computationalâ€”truths. Happy pigeonholing!</p>
    <h3>References:</h3>
    
  </section>


</body>
</html>
