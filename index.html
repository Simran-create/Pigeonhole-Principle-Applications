<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>How Infinity Hides into Your Algorithms</title>
  <style>
    body { max-width:900px; margin:auto; padding:20px;
           font-family:Segoe UI,Arial,sans-serif; color:#333; line-height:1.6; }
    nav { position:sticky; top:0; background:#fff; padding:10px 0;
          border-bottom:1px solid #ddd; margin-bottom:20px; }
    nav a { margin:0 12px; text-decoration:none; color:#0077cc; font-weight:500; }
    section { margin-bottom:50px; }
    h1,h2,h3 { color:#222; }
    h1 { font-size:2em; margin-bottom:0.2em; }
    h2 { font-size:1.6em; border-bottom:2px solid #eee; padding-bottom:0.2em; }
    .viz { text-align:center; margin:20px 0; }
    iframe { width:100%; height:400px; border:1px solid #ccc; border-radius:4px; }
    .callout { background:#f0f8ff; border-left:4px solid #66aaff;
               padding:12px; margin:20px 0; font-style:italic; }
  </style>
  <!-- For image rendering -->
  <style>
  body {
  }

  .center-img-container {
    margin: 0;
    padding: 0;
    text-align: center;
    padding: 10px 0;
  }

  .center-img-container img {
    max-width: 50%;
    max-height: 50vh;
    height: auto;
    display: inline-block;
    vertical-align: middle;
    margin: 0 auto;
  }
  </style>



  <!-- MathJax configuration -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      chtml: { scale:1, minScale:1 }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>

  <h1>How Infinity Hides into Your Algorithms</h1>
  <nav>
    <a href="#intro">Introduction</a>
    <a href="#baby">The Baby PHP</a>
    <a href="#infinite">Infinite Applications</a>
    <a href="#cs">CS Uses</a>
    <a href="#proofs">Surprising Proofs</a>
    <a href="#art">The Art</a>
    <a href="#closing">Closing</a>
  </nav>

  <section id="intro">
    <h2>Introduction</h2>
    <p><em>‚ÄúYou cannot put 10 socks in 9 drawers without something overlapping, obvious right? But this trivial fact lets you prove infinite truths, detect collisions in cryptography, and defeat compression algorithms.‚Äù</em></p>
    <p>The Pigeonhole Principle (PHP)‚Äî‚Äúif you have more pigeons than holes, at least one hole must contain at least two pigeons‚Äù‚Äîfeels like kindergarten. Yet it powers:</p>
    <ul>
      <li>‚úñÔ∏è Functions that <strong>fail to be injective</strong></li>
      <li>üóúÔ∏è Data files that <strong>can‚Äôt be compressed</strong></li>
      <li>üîê Cryptosystems that <strong>inevitably collide</strong></li>
      <li>‚ôæÔ∏è Infinite sets with <strong>no least member</strong></li>
    </ul>
  </section>

  <section id="baby">
    <h2>1. The Baby Pigeonhole Principle</h2>
    <h3>Formal Statement</h3>
    <p><strong>1.1 Pigeonhole Principle (finite version):</strong> Suppose n objects (pigeons) are distributed among m containers (holes). If n > m, then at least one container must contain at least two objects.</p>
    <p>Alternatively, if each container has at most one object, you can place at most m objects total. Once you place a (m+1)th, you force a container to have two.</p>
    <h3>Visual Demonstration</h3>
    <div class="viz"><iframe src="socks.html"></iframe></div>
    <h3>1.2 Birthday Paradox (Basic counting)</h3>
    <p><strong>Setup:</strong> Consider 23 people in a room. There are 365 possible birthdays.</p>
    <p><strong>Application of PHP:</strong> Since 23 < 365, the basic PHP does not force a collision. But if we has 366 people, two must share a birthday.</p>
    <p><strong>Remark.</strong> The ‚Äùbirthday paradox‚Äù probability calculation shows that collisions happen much earlier than 366; but PHP gives a guarantee only when participants > 366.
     </p>
    <h3>1.3 Matching problems</h3>
    <p>If you have 5 red balls and 5 blue balls in 9 boxes, whatever arrangement, at least one box has at least 2 balls.</p>
    <p>More generally, distributing n items into k catagories forces at least $$
      \left\lceil \frac{n}{k} \right\rceil
      $$ items in one catagory.</p>
    <h3>1.4 Why this simple idea matters</h3>
    <li><strong>Universality.</strong> Any time you try to squeeze more objects into fewer ‚Äúslots,‚Äù you get overlap.</li>
    <li><strong>Certainty.</strong> Unlike probabilistic arguments, PHP yields a strict, deterministic guarantee.</li>
    <li><strong>Foundation.</strong> Many elementary proofs (e.g., in combinatorics, graph theory, and number theory) rest on pigeonholes.</li>
  </section>

  <section id="infinite">
    <h2>2. Going Deeper‚ÄîInfinite Applications</h2>
    <p> While the finite PHP is easy, there are <strong>‚Äúinfinite‚Äù</strong> analogues that let you extract surprising conclusions from seemingly weak assumptions.</p>.
    <h3>2.1 Infinite Pigeonhole Principle</h3>
    <p><strong>Infinite Pigeonhole Principle (Weak form)</strong> If infinitely many objects (pigeons) are distributed among finitely many categories (holes), then at least one category must contain infinitely many objects.</p>
    <p><strong>Why.</strong> Suppose you have infinitely many items x1, x2, x3,... and only m catagories. If each category held only finitely many, say at most Ni in catagory i, then the total objects would be at most N1 + N2 + ... +Nm < ‚àû. That contradicts ‚Äúinfinitely many.‚Äù Hence some category is infinite.</p>
    <p><strong>Diagram 1:</strong> Imagine we assign each natural number n ‚àà N to one of 3 bins labeled A, B, C. If infinitely many numbers exist, one bin must collect infinitely many:</p>
    <p><strong>Bins:</strong>  [ A ],   &nbsp; &nbsp; [ B ], &nbsp; &nbsp;   [ C]</p>
    <p><strong>Numbers:</strong> 1‚ÜíB &nbsp; &nbsp; 2‚ÜíA &nbsp; &nbsp; 3‚ÜíC &nbsp; &nbsp; 4‚ÜíB &nbsp; &nbsp; 5‚ÜíC &nbsp; &nbsp; 6‚ÜíB &nbsp; &nbsp; 7‚ÜíA &nbsp; &nbsp; 8‚ÜíC &nbsp; &nbsp;9‚ÜíB ...</p>
    <p>Since there are infinitely many natural numbers, at least one bin, say B, receives infinitely many.</p>
    <div class="viz"><iframe src="bins.html"></iframe></div>
    <h3>2.2 Dirichlet‚Äôs Approximation Theorem</h3>
    <p><strong>Dirichlet‚Äôs Theorem.</strong></p>
    <p>For any real Œ± and any integer N ‚â• 1. there exist integers p and q with 1‚â§ q ‚â§ N    $$\bigl|\alpha - \tfrac{p}{q}\bigr| < \tfrac1{qN},\quad 1\le q\le N$$ </p>
   
    <p><strong>Sketch using pigeonholes.</strong></p>
    <p>1. Consider the N + 1 real numbers{ Œ± }, { 2Œ± }, { 3Œ± }, . . . , { NŒ± },where {x} denotes the fractional part of {n}. Each { kŒ± } lies in [0, 1).</p>
    <p>2. Partition the interval [0, 1) into N smaller half-open subintervals (‚Äúholes‚Äù): $$
[0,\tfrac{1}{N}), \;\; [\tfrac{1}{N},\tfrac{2}{N}), \;\dots,\; [\tfrac{N-1}{N},1).   $$</p>
    <p>3. By the (finite) PHP, two of the N + 1 fractional parts, say iŒ± and jŒ± with i < j ‚â§ N, must land in the same interval of length 1/N. Therefore,  $$
    \bigl| \{\,j\alpha\} - \{\,i\alpha\} \bigr| < \frac{1}{N}.  $$ </p>
    <p>4. But { jŒ± } ‚àí { iŒ± } equals {( j ‚àíi )Œ±} (up to possibly ¬±1), so there is an integer q = j ‚àíi (1 ‚â§ q ‚â§ N) and integer p = ‚åä jŒ± ‚åã ‚àí ‚åä iŒ± ‚åã such that $$
    \left|\, q\,\alpha - p \right| < \frac{1}{N}
    \quad\Longrightarrow\quad
    \left|\, \alpha - \frac{p}{q} \right| < \frac{1}{q\,N}.
    $$ 
    Thus infinite conclusions‚Äîapproximation of irrationals‚Äîfollow from partitioning a finite interval. </p>
    <h3>2.3 Irrationality of ‚àö2</h3>
    <p>A classic proof of ‚àö2 being irrational is not pigeonhole-style, but one can recast it via Dirichlet‚Äôs theorem:
    <ol><li>If ‚àö2 = p/q exactly, then |‚àö2 ‚àí p/q| = 0.</li>
        <li>But Dirichlet‚Äôs theorem guarantees infinitely many rational approximations p/q with $$
   \left| \sqrt{2} - \frac{p}{q} \right| < \frac{1}{q\,N}. $$  For large N, 1/qN < 0 is impossible, so no exact equality can hold.</li></ol></p>
    <p>This view shows that no rational can equal ‚àö2, since rationals do not achieve these ‚Äútoo-good‚Äù approximations infinitely often.</p>
    <h3>2.4 Uncountability of the Real Numbers</h3>
      <p>While Cantor‚Äôs diagonal argument is the most common proof, here is a pigeonhole-flavored reasoning: <ol>
        <li>Suppose for contradiction R is countable. List all real numbers in [0, 1] as r1, r2, r3, . . . .</li>
        <li> For each n, consider the decimal expansion of r_n truncated at n digits. That is, let $$ s_n = \text{first n digits of} \hspace{2mm} r_n n [0, 1]. $$
Each s_n lies in one of the 10^n intervals of the for $$\bigl[\,0.d_1 d_2 \dots d_n,\;0.d_1 d_2 \dots d_n + 10^{-n}\bigr).$$ </li>
        <li> For each n, assign r_n to the ‚Äúinterval‚Äù corresponding to its truncated form s_n. As n ‚Üí ‚àû, we would be distributing infinitely many reals into 
             a <strong>strictly finite</strong> number of decimal-truncation intervals at each stage‚Äîforcing some interval to contain infinitely many ‚Äútails.‚Äù</li>
        <li> By a diagonal-type selection, you can then construct a real number not in your original list, contradicting countability. This is somewhat more involved than the standard diagonal, 
but it highlights how <strong>infinitely many pigeons (reals) into finitely many ‚Äúdecimal-prefix slots‚Äù</strong> forces a new real outside the enumeration</li>
      </ol></p>   
  </section>

  <section id="cs">
    <h2>3. Pigeonholes in Algorithms and Computer Science</h2>
    <p>Modern computer science often exploits pigeonhole reasoning to show collisions, impossibility of lossless compression, and security bounds. Below are key applications</p>
    <h3>3.1 Hashing and Collisions</h3>
    <p>$$ \text{Setup:} \hspace{2mm} \text{A hash function h} : \hspace{2mm} \{0, 1\}^n ‚Üí \{0, 1\}^m \hspace{2mm} \text{maps n-bit inputs to m-bit outputs, where m < n} $$ </p>
    <p> <strong>Pigeonhole argument.</strong> There are 2^n possible inputs (‚Äúpigeons‚Äù) but only 2^m hash-values (‚Äúholes‚Äù). 
          If 2^n > 2^m, then by PHP, some hash-value must be attained by at least two distinct inputs‚Äîi.e., a collision</p>
    <p><strong>Implication.</strong> No hash function can be injective once n > m. In practice, cryptographic hashes are designed to make collisions hard to find even if they must exist.</p>
    <p><strong>Diagram:</strong> Inputs vs Hash Buckets $$ \text{Inputs} \hspace{2mm} 2^n \hspace{2mm} \text{pigeons):} \hspace{1mm}  x_1, \hspace{1mm} x_2, \hspace{1mm} x_3, \hspace{1mm} ..., \hspace{1mm}x_2n $$</p>
    <p>Hash Buckets (2^m holes): [ 0 ] [ 1 ] ... [ 2m ‚àí 1 ]</p>
    <p>Since 2^n ‚â´ 2^m, many inputs are forced to map into the same bucket</p>
    <div class="viz"><iframe src="hash.html"></iframe></div>
    <h3>3.2 Compression Paradox</h3>
    <p><strong>Claim.</strong> No lossless compression algorithm can compress <strong>every</strong> file to a shorter representation</p>
    <p><strong>Intuition.</strong> Suppose you have an algorithm C that maps any bit-string of length L into a shorter string of length < L.</p>
    <p><strong>Counting argument.</strong> $$ \text{There are} \hspace{2mm} 2^L \hspace{2mm} \text{distinct input strings of length L. But the algorithm can only output strings of length at most L ‚àí 1,} $$ </p>
    <p> $$ \text{so there are at most} 2^0 + 2^1 + 2^2 + \dots + 2^{L-1} \;=\; 2^{L}-1 \hspace{2mm} \text{possible outputs} $$</p>
    <p><strong>Conclusion (pigeonhole).</strong> By PHP, at least two distinct inputs of length L must map to the same output. The compression fails to be lossless.</p>
    <p><strong>Corollary.</strong> Any ‚Äúuniversal‚Äù compressor must expand some files‚Äîno magic algorithm compresses every file. In practice, compressors like ZIP exploit patterns in real-world data; but in the worst case
(e.g., random data), they cannot shrink everything.</p>
    <h3>3.3 Birthday Attacks in Cryptography</h3>
    <p>Let H be a hash function producing m-bit outputs. If an adversary picks random inputs and computes hashes, then:</p>
    <p>$$ \text{Birthday Paradox. After about} \hspace{1mm} 2^{m/2} \hspace{1mm} \text{random inputs, the probability of finding a collision in hashvalues becomes significant (50%).}$$</p>
    <p>$$ \text{Pigeonhole argument (simplified). There are} \hspace{1mm} 2^m \hspace{1mm} \text{hash-values (‚Äúholes‚Äù). Sampling N random inputs (‚Äúpigeons‚Äù),} $$ </p>
    <p>$$ \text{the expected number of collisions arises when} \hspace{1mm} N ‚âà \sqrt{2^m}. \hspace{1mm} \text{Though not strictly PHP, the intuition stems from ‚Äúif} $$ </p>
    <p>$$ \text{you place about the} \hspace{1mm} \sqrt{2^m} \hspace{1mm} \text{pigeons into} \hspace{1mm} 2^m \hspace{1mm} \text{holes, collisions become likely.‚Äù} $$</p>
    <p><strong>Implication.</strong> To resist birthday attacks, choose m large (e.g., m = 256 for SHA-256). Then 2^128 effort is required to find a collision by brute force, which is currently computationally infeasible.</p>
    <h3>3.4 Load Balancing and Cache Design</h3>
    <p>Suppose you have k servers (or cache slots) and want to assign n tasks (or memory blocks) dynamically:</p>
    <p>If n > k and tasks are all ‚Äúhot,‚Äù by simple pigeonhole, at least one server must handle at least ‚åàn/k‚åâ tasks simultaneously‚Äîcreating a bottleneck.</p>
    <p><strong>Cache lines.</strong> Consider a CPU cache with B cache lines and N distinct memory blocks. If a program accesses N blocks where N > B 
 while reusing them in some pattern, eventually some cache line must evict another (due to PHP). This underlies cache-miss lower bounds in algorithms.</p>
    <p><strong>Balanced hashing (Cuckoo, Consistent Hashing).</strong>strong> These techniques try to distribute ‚Äúpigeons‚Äù (requests) evenly among ‚Äúholes‚Äù (servers), but ultimately if you have more requests than servers, some server must bear extra load.</p> 
  </section>

  <section id="proofs">
    <h2>4. Surprising Proofs</h2>
    Beyond hashing and algorithms, pigeonhole ideas often hide inside elegant combinatorial proofs.
    <h3>4.1 Erd&#337;s‚ÄìSzekeres: Monotonic Subsequence</h3>
    
    <p><strong>Theorem (Erd&#337;s‚ÄìSzekeres).</strong></p>
    <p>Any sequence of mn + 1 distinct real numbers contains either an increasing subsequence of length m + 1 or a decreasing subsequence of length n + 1.</p>
    <p><strong>Proof Sketch (pigeonhole coloration).</strong> 1. Let the sequence be a1, a2, . . . , a_mn+1.</p>
    <p>2. For each position i, define two numbers: <br>
      L(i) = length of longest increasing subsequence starting at a_i. <br> D(i) = length of longest decreasing subsequence starting at a_i.</p>
    <p>3. We know 1 ‚â§ L(i) ‚â§ m + 1 and 1 ‚â§ D(i) ‚â§ n + 1. Consider the set of ordered pairs {(L(i), D(i)) : 1 ‚â§ i ‚â§ mn + 1}.</p>
    <p>4.  There are only m √ó n possible pairs (u, v) with 1 ‚â§ u ‚â§ m and 1 ‚â§ v ‚â§ n. Actually, if either L(i) = m+1 or D(i) = n+1 for some i, 
we are done (we found our long monotonic subsequence). Otherwise, each i corresponds to a pair in {1, . . . , m} √ó {1, . . . , n}.</p>
    <p>Since we have mn + 1 indices but only mn possible (L, D) values with both coordinates (m, n), by PHP at least two indices i < j must share the same L(i), D(i) = L(j), D(j). </p>
    <p>One then shows‚Äîby comparing ai and aj‚Äîthat either there is a longer increasing or a longer decreasing subsequence than assumed, contradiction. Hence the desired monotonic subsequence must exist.</p>
    <div class="center-img-container">
      <img src="Grid of (L, D) values.png" alt="Grid of (L, D) values">    
    </div>

 
    <p>Once two indices map to the same grid cell (u, v) and neither coordinate is at the max, one of the monotonic subsequences can be extended‚Äîleading to a contradiction if you assumed no long subsequences existe</p>
    <h3><strong>$$ \text{4.2 Ramsey Theory: Triangles in} K_6 $$</strong></h3>
    <p>Fact. Any 2-coloring of the edges of the complete graph K6 on 6 vertices must contain a monochromatic triangle (either all-red or all-blue).</p>
    <p><strong>Pigeonhole proof sketch</strong></p>
    <p><strong>1.</strong> Label vertices V = {v1, v2, v3, v4, v5, v6}. Consider vertex v1. It has 5 incident edges, each colored red (R) or blue (B).</p>
    <p><strong>2.</strong> By PHP, at least three of those edges must share the same color, say red. Without loss of generality, edges {v1v2, v1v3, v1v4} are all re</p>
    <p><strong>3.</strong> Now look at the triangle formed by vertices v2, v3, v4. If any of those edges is red, say {v2v3}, then {v1, v2, v3} forms a red triangle. If none are red, all three edges {v2v3, v3v4, v2v4} must be blue, forming a blue triangle among {v2, v3, v4}.</p>
    <p><strong>4.</strong> In either case, we find a monochromatic triangle.</p>
      <div class="viz"><iframe src="star.html"></iframe></div>
    <p>From v1, three red edges go to v2, v3, v4. Among {v2, v3, v4}, either a red edge exists (closing a red triangle) or all are blue (forming a blue triangle).</p>
    <h3>5.3 Monochromatic Subsets (Ramsey-Flavored)</h3>
    <p>More generally, if you color the edges of a sufficiently large complete graph K_n in c colors, pigeonhole arguments often help find monochromatic cliques of a given size. 
                       While standard proofs use induction, the base cases rely on simple pigeonhole partitions of edges.</p>
  </section>

  <section id="art">
    <h2>5. The Art of Finding the Right Pigeonholes</h2>
    <p>So far, we‚Äôve applied pigeonhole in rather straightforward ways‚Äîgrouping objects by obvious categories. In more advanced problems, 
      the creative insight is in designing the ‚Äúholes‚Äù so that the PHP yields a nontrivial conclusion.</p>
    <h3>5.1 The ‚ÄúDuality‚Äù of Pigeonhole: Existence vs. Impossibility</h3>
    <p><li><strong>Existence proofs.</strong> Show that a certain structure must exist. Example: ErdÀùos‚ÄìSzekeres guarantees a long monotonic subsequence.</li>
    <li><strong>Impossibility proofs.</strong> Show that a certain algorithm or mapping cannot exist. Example: compression paradox, hashing injectivity.</li></p>
    <p>In both, you define a mapping (objects) ‚Üí (categories), and then count objects vs. categories.</p>
    <h3>5.2 Choosing Pigeonholes: Several Tips</h3>
    <ol>
      <li><strong>Map to a Finite Set.</strong> If you suspect an infinite conclusion (e.g., find infinitely many with some property), map infinitely many items to a finite set (e.g., basic types, intervals, residues modulo m).</li>
      <li><strong>Colors, Types, Intervals</strong>
      <uL>
        <li><strong>Colors. </strong>In graph theory or combinatorics, ‚Äúcolor‚Äù edges or vertices into a small number of classes.</li>
        <li><strong>Residue classes. </strong>In number theory, assign integers to {0,1,..., d-1} by taking remainders mod d.</li>
        <li><strong>Intervals. </strong>When dealing with real numbers, subdivide [0, 1] into intervals of length Œµ.</li>
      </uL></li>
      <li><strong>Look for Quantitative Bounds. </strong>If a problem asks to prove ‚Äúsome subset of size k exists,‚Äù you often partition into fewer than k categories‚Äîforcing a large class by PHP.</li>
      <li><strong>Symmetry Helps. </strong>When elements are exchangeable (e.g., vertices of a complete graph), you can assume one vertex is special and count its incident edges or neighbors.</li>
      <li><strong>Antichains and Chains. </strong>In partially ordered sets (posets), map each element to the length of the longest chain (or antichain) through it. Comparing lengths forces either a long chain or long antichain. This is the classic Dilworth/ErdÀùos‚ÄìSzekeres approach.</li>
    </ol>
  </section>

  <section id="closing">
    <h2>Closing</h2>
    <p>From ‚Äúyou can‚Äôt put 10 socks in 9 drawers‚Äù to ‚Äúno universal compressor can shrink every file,‚Äù the Pigeonhole Principle reveals astonishing power. By carefully choosing ‚Äúholes‚Äù‚Äîintervals, residue classes, colors, or substructures‚Äîone transforms a <strong>finite counting argument</strong> into far-reaching conclusions.
    <li><strong>Infinite conclusions:</strong> Dirichlet‚Äôs approximation, uncountability, and existence of infinite subsets</li>
    <li><strong>Cryptographic bounds: </strong>collisions in hashing, birthday attacks in SHA, and security parameters.</li>
    <li><strong>Combinatorial certainties:</strong> monotonic subsequences, Ramsey-style triangles, and anticliques in posets</li>
    <li><strong>Impossibility theorems:</strong> compression paradox, injective limitations, and cache lower bounds</li>
    </p>
    <p>Every time you feel stuck‚Äîwhen a problem hints at ‚Äútoo many items to fit in too few categories‚Äù‚Äîreach for the Pigeonhole Principle.</p>
    <p><strong>Call to Action. </strong>Next time you see ‚Äúmore objects than categories,‚Äù pause. Can you define the categories (pigeonholes) so that PHP gives you exactly the statement you need? Look around‚Äîevery limitation hides a powerful truth waiting to be unearthed.</p>
    <h3>7.1 Further Exploration</h3>
    <p>If you want to dive deeper, consider these <strong>self-contained</strong> exercises:</p>
    <p><strong>1. Dirichlet‚Äôs Bound on œÄ.</strong> Show that there are infinitely many rational approximations p/q to œÄ satisfying $$\left|\pi - \tfrac{p}{q}\right| < \tfrac{1}{q^2},$$ using a pigeonhole partition of {kœÄ} into intervals of length 1/N.</p>
    <p><strong>2. Ramsey Number R(4, 4).</strong> By extending the ‚Äústar-center‚Äù pigeonhole idea, prove that any 2-coloring of <code>K_18</code> contains a monochromatic K4. 
      (Hint: Partition edges incident to a vertex into two colors; then apply the R(3, 3) = 6 result on neighbors.)</p>

    <p><strong>3.Generalized PHP in Metric Spaces.</strong> Given infinitely many points in [0, 1]^2, partition the square into a n√ón grid of little squares. Show one small square contains infinitely many points‚Äîyielding a cluster point for Bolzano‚ÄìWeierstrass.</p>
    <blockquote>Each of these tasks reinforces the key insight: finite partitions force infinite structure.</blockquote>
    <p><strong>Remember:</strong> The simplest idea‚Äî‚Äúif more pigeons than holes, two share a hole‚Äù‚Äîis often the key to both elementary and deep mathematical‚Äîand computational‚Äîtruths. Happy pigeonholing!</p>
    <h3>References:</h3>
    
  </section>


</body>
</html>
