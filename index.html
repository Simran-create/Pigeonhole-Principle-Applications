<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>How Infinity Hides into Your Algorithms</title>
  

  <style>
    body { max-width:900px; margin:auto; padding:20px;
           font-family:Segoe UI,Arial,sans-serif; color:#333; line-height:1.6; }
    nav { position:sticky; top:0; background:#fff; padding:10px 0;
          border-bottom:1px solid #ddd; margin-bottom:20px; }
    nav a { margin:0 12px; text-decoration:none; color:#0077cc; font-weight:500; }
    section { margin-bottom:50px; }
    h1,h2,h3 { color:#222; }
    h1 { font-size:2em; margin-bottom:0.2em; }
    h2 { font-size:1.6em; border-bottom:2px solid #eee; padding-bottom:0.2em; }
    .viz { text-align:center; margin:20px 0; }
    iframe { width:100%; height:400px; border:1px solid #ccc; border-radius:4px; }
    .callout { background:#f0f8ff; border-left:4px solid #66aaff;
               padding:12px; margin:20px 0; font-style:italic; }
  </style>

  <!-- MathJax configuration -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      chtml: { scale:1, minScale:1 }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>

  <h1>How Infinity Hides into Your Algorithms</h1>
  <nav>
    <a href="#intro">Introduction</a>
    <a href="#baby">The Baby PHP</a>
    <a href="#infinite">Infinite Applications</a>
    <a href="#cs">CS Uses</a>
    <a href="#proofs">Surprising Proofs</a>
    <a href="#art">The Art</a>
    <a href="#closing">Closing & References</a>
  </nav>

  <section id="intro">
    <h2>Introduction</h2>
    <p><em>‚ÄúYou cannot put 10 socks in 9 drawers without something overlapping, obvious right? But this trivial fact lets you prove infinite truths, detect collisions in cryptography, and defeat compression algorithms.‚Äù</em></p>
    <p>The Pigeonhole Principle (PHP)‚Äî‚Äúif you have more pigeons than holes, at least one hole must contain at least two pigeons‚Äù‚Äîfeels like kindergarten. Yet it powers:</p>
    <ul>
      <li>‚úñÔ∏è Functions that <strong>fail to be injective</strong></li>
      <li>üóúÔ∏è Data files that <strong>can‚Äôt be compressed</strong></li>
      <li>üîê Cryptosystems that <strong>inevitably collide</strong></li>
      <li>‚ôæÔ∏è Infinite sets with <strong>no least member</strong></li>
    </ul>
  </section>

  <section id="baby">
    <h2>1. The Baby Pigeonhole Principle</h2>
    <h3>Formal Statement</h3>
    <p><strong>PHP (finite version):</strong> Suppose n objects (pigeons) are distributed among m containers (holes). If n > m, then at least one container must contain at least two objects.</p>
    <p>Alternatively, if each container has at most one object, you can place at most m objects total. Once you place a (m + 1)th, you force a container to have two.</p>
    <h3>Visual Example</h3>
    <div class="viz"><iframe src="socks.html"></iframe></div>
    <h3>Birthday Paradox (Basic counting)</h3>
    <p><strong>Setup:</strong> Consider 23 people in a room. There are 365 possible birthdays.</p>
    <p><strong>Application of PHP:</strong> Since 23 < 365, the basic PHP does not force a collision. But if we has 366 people, two must share a birthday.</p>
    <p><strong>Remark.</strong> The ‚Äùbirthday paradox‚Äù probability calculation shows that collisions happen much earlier than 366; but PHP gives a guarantee only when participants > 366.
     </p>
    <h3>Matching problems</h3>
    <p>If you have 5 red balls and 5 blue balls in 9 boxes, whatever arrangement, at least one box has at least 2 balls.</p>
    <p>More generally, distributing n items into k catagories forces at least $$
      \left\lceil \frac{n}{k} \right\rceil
      $$ items in one catagory.</p>
    <h3>Why this simple idea matters</h3>
    <li><strong>Universality.</strong> Any time you try to squeeze more objects into fewer ‚Äúslots,‚Äù you get overlap.</li>
    <li><strong>Certainty.</strong> Unlike probabilistic arguments, PHP yields a strict, deterministic guarantee.</li>
    <li><strong>Foundation.</strong> Many elementary proofs (e.g., in combinatorics, graph theory, and number theory) rest on pigeonholes.</li>
  </section>

  <section id="infinite">
    <h2>2. Going Deeper‚ÄîInfinite Applications</h2>
    <p> While the finite PHP is easy, there are <strong>‚Äúinfinite‚Äù</strong> analogues that let you extract surprising conclusions from seemingly weak assumptions.</p>.
    <h3> Infinite Pigeonhole Principle</h3>
    <p><strong>Infinite Pigeonhole Principle (Weak form)</strong>If infinitely many objects (pigeons) are distributed among finitely many categories (holes), then at least one category must contain infinitely many objects.</p>
    <p><strong>Why.</strong> Suppose you have infinitely many items x1, x2, x3,... and only m catagories. If each category held only finitely many, say at most Ni in catagory i, then the total objects would be at most N1 + N2 + ... +Nm < ‚àû. That contradicts ‚Äúinfinitely many.‚Äù Hence some category is infinite.</p>
    <p><strong>Diagram 1:</strong></p>
    <div class="viz"><iframe src="bins.html"></iframe></div>
    <h3>Dirichlet‚Äôs Approximation</h3>
    <div class="callout">
      $$\bigl|\alpha - \tfrac{p}{q}\bigr| < \tfrac1{qN},\quad 1\le q\le N$$
    </div>
  </section>

  <section id="cs">
    <h2>3. Pigeonholes in Computer Science</h2>
    <h3>Hashing &amp; Collisions</h3>
    <p>If $n$-bit inputs map to $m$-bit outputs with $n>m$, collisions are forced.</p>
    <div class="viz"><iframe src="hash.html"></iframe></div>
    <h3>Compression Paradox</h3>
    <div class="callout">
      $$2^0+2^1+\dots+2^{L-1}=2^L-1$$
    </div>
  </section>

  <section id="proofs">
    <h2>4. Surprising Proofs</h2>
    <h3>Erd≈ës‚ÄìSzekeres</h3>
    <p>Sequence length $mn+1$ ‚áí inc.\ subseq.\ $m+1$ or dec.\ $n+1$.</p>
    <div class="viz"><iframe src="grid.html"></iframe></div>
    <h3>Ramsey in $K_6$</h3>
    <div class="viz"><iframe src="star.html"></iframe></div>
  </section>

  <section id="art">
    <h2>5. The Art of Finding the Right Pigeonholes</h2>
    <p>So far, we‚Äôve applied pigeonhole in rather straightforward ways‚Äîgrouping objects by obvious categories. In more advanced problems, 
      the creative insight is in designing the ‚Äúholes‚Äù so that the PHP yields a nontrivial conclusion.</p>
    <h3>5.1 The ‚ÄúDuality‚Äù of Pigeonhole: Existence vs. Impossibility</h3>
    <p><li><strong>Existence proofs.</strong> Show that a certain structure must exist. Example: ErdÀùos‚ÄìSzekeres guarantees a long monotonic subsequence.</li>
    <li><strong>Impossibility proofs.</strong> Show that a certain algorithm or mapping cannot exist. Example: compression paradox, hashing injectivity.</li></p>
    <p>In both, you define a mapping (objects) ‚Üí (categories), and then count objects vs. categories.</p>
    <h3>5.2 Choosing Pigeonholes: Several Tips</h3>
    <ol>
      <li><strong>Map to a Finite Set.</strong> If you suspect an infinite conclusion (e.g., find infinitely many with some property), map infinitely many items to a finite set (e.g., basic types, intervals, residues modulo m).</li>
      <li><strong>Colors, Types, Intervals</strong>
      <uL>
        <li><strong>Colors. </strong>In graph theory or combinatorics, ‚Äúcolor‚Äù edges or vertices into a small number of classes.</li>
        <li><strong>Residue classes. </strong>In number theory, assign integers to {0,1,..., d-1} by taking remainders mod d.</li>
        <li><strong>Intervals. </strong>When dealing with real numbers, subdivide [0, 1] into intervals of length Œµ.</li>
      </uL></li>
      <li><strong>Look for Quantitative Bounds. </strong>If a problem asks to prove ‚Äúsome subset of size k exists,‚Äù you often partition into fewer than k categories‚Äîforcing a large class by PHP.</li>
      <li><strong>Symmetry Helps. </strong>When elements are exchangeable (e.g., vertices of a complete graph), you can assume one vertex is special and count its incident edges or neighbors.</li>
      <li><strong>Antichains and Chains. </strong>In partially ordered sets (posets), map each element to the length of the longest chain (or antichain) through it. Comparing lengths forces either a long chain or long antichain. This is the classic Dilworth/ErdÀùos‚ÄìSzekeres approach.</li>
    </ol>
  </section>

  <section id="closing">
    <h2>Closing</h2>
    <p>From ‚Äúyou can‚Äôt put 10 socks in 9 drawers‚Äù to ‚Äúno universal compressor can shrink every file,‚Äù the Pigeonhole Principle reveals astonishing power. By carefully choosing ‚Äúholes‚Äù‚Äîintervals, residue classes, colors, or substructures‚Äîone transforms a <strong>finite counting argument</strong> into far-reaching conclusions.
    <li><strong>Infinite conclusions:</strong> Dirichlet‚Äôs approximation, uncountability, and existence of infinite subsets</li>
    <li><strong>Cryptographic bounds: </strong>collisions in hashing, birthday attacks in SHA, and security parameters.</li>
    <li><strong>Combinatorial certainties:</strong> monotonic subsequences, Ramsey-style triangles, and anticliques in posets</li>
    <li><strong>Impossibility theorems:</strong> compression paradox, injective limitations, and cache lower bounds</li>
    </p>
    <p>Every time you feel stuck‚Äîwhen a problem hints at ‚Äútoo many items to fit in too few categories‚Äù‚Äîreach for the Pigeonhole Principle.</p>
    <p><strong>Call to Action. </strong>Next time you see ‚Äúmore objects than categories,‚Äù pause. Can you define the categories (pigeonholes) so that PHP gives you exactly the statement you need? Look around‚Äîevery limitation hides a powerful truth waiting to be unearthed.</p>
    <h3>7.1 Further Exploration</h3>
    <p>If you want to dive deeper, consider these <strong>self-contained</strong> exercises:</p>
    <p><strong>1. Dirichlet‚Äôs Bound on œÄ.</strong> Show that there are infinitely many rational approximations p/q to œÄ satisfying $$\left|\pi - \tfrac{p}{q}\right| < \tfrac{1}{q^2}$$, using a pigeonhole partition of {kœÄ} into intervals of length 1/N.</p>
    <p><strong>2. Ramsey Number R(4, 4).</strong> By extending the ‚Äústar-center‚Äù pigeonhole idea, prove that any 2-coloring of <code>K_18</code> contains a monochromatic K4. 
      (Hint: Partition edges incident to a vertex into two colors; then apply the R(3, 3) = 6 result on neighbors.)</p>

    <p><strong>3.Generalized PHP in Metric Spaces.</strong> Given infinitely many points in <code>[0, 1]^2</code>, partition the square into a n√ón grid of little squares. Show one small square contains infinitely many points‚Äîyielding a cluster point for Bolzano‚ÄìWeierstrass.</p>
    <blockquote>Each of these tasks reinforces the key insight: finite partitions force infinite structure.</blockquote>
    <p><strong>Remember:</strong> The simplest idea‚Äî‚Äúif more pigeons than holes, two share a hole‚Äù‚Äîis often the key to both elementary and deep mathematical‚Äîand computational‚Äîtruths. Happy pigeonholing!</p>
    <h3>References:</h3>
    
  </section>


</body>
</html>
