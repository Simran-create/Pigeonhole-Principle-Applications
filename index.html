<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>How Infinity Hides into Your Algorithms</title>
  

  <style>
    body { max-width:900px; margin:auto; padding:20px;
           font-family:Segoe UI,Arial,sans-serif; color:#333; line-height:1.6; }
    nav { position:sticky; top:0; background:#fff; padding:10px 0;
          border-bottom:1px solid #ddd; margin-bottom:20px; }
    nav a { margin:0 12px; text-decoration:none; color:#0077cc; font-weight:500; }
    section { margin-bottom:50px; }
    h1,h2,h3 { color:#222; }
    h1 { font-size:2em; margin-bottom:0.2em; }
    h2 { font-size:1.6em; border-bottom:2px solid #eee; padding-bottom:0.2em; }
    .viz { text-align:center; margin:20px 0; }
    iframe { width:100%; height:400px; border:1px solid #ccc; border-radius:4px; }
    .callout { background:#f0f8ff; border-left:4px solid #66aaff;
               padding:12px; margin:20px 0; font-style:italic; }
  </style>

  <!-- MathJax configuration -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      chtml: { scale:1, minScale:1 }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>

  <h1>How Infinity Hides into Your Algorithms</h1>
  <nav>
    <a href="#intro">Introduction</a>
    <a href="#baby">The Baby PHP</a>
    <a href="#infinite">Infinite Apps</a>
    <a href="#cs">CS Uses</a>
    <a href="#proofs">Surprising Proofs</a>
    <a href="#art">The Art</a>
    <a href="#closing">Closing</a>
  </nav>

  <section id="intro">
    <h2>Introduction</h2>
    <p><em>‚ÄúYou cannot put 10 socks in 9 drawers without something overlapping, obvious right? But this trivial fact lets you prove infinite truths, detect collisions in cryptography, and defeat compression algorithms.‚Äù</em></p>
    <p>The Pigeonhole Principle (PHP)‚Äî‚Äúif you have more pigeons than holes, at least one hole must contain at least two pigeons‚Äù‚Äîfeels like kindergarten. Yet it powers:</p>
    <ul>
      <li>‚úñÔ∏è Functions that <strong>fail to be injective</strong></li>
      <li>üóúÔ∏è Data files that <strong>can‚Äôt be compressed</strong></li>
      <li>üîê Cryptosystems that <strong>inevitably collide</strong></li>
      <li>‚ôæÔ∏è Infinite sets with <strong>no least member</strong></li>
    </ul>
  </section>

  <section id="baby">
    <h2>1. The Baby Pigeonhole Principle</h2>
    <h3>Formal Statement</h3>
    <p><strong>PHP (finite version):</strong> Suppose n objects (pigeons) are distributed among m containers (holes). If n > m, then at least one container must contain at least two objects.</p>
    <p>Alternatively, if each container has at most one object, you can place at most m objects total. Once you place a (m + 1)th, you force a container to have two.</p>
    <h3>Visual Example</h3>
    <div class="viz"><iframe src="socks.html"></iframe></div>
    <h3>Birthday Paradox (Basic counting)</h3>
    <p><strong>Setup:</strong> Consider 23 people in a room. There are 365 possible birthdays.</p>
    <p><strong>Application of PHP:</strong> Since 23 < 365, the basic PHP does not force a collision. But if we has 366 people, two must share a birthday.</p>
    <p><strong>Remark.</strong> The ‚Äùbirthday paradox‚Äù probability calculation shows that collisions happen much earlier than 366; but PHP gives a guarantee only when participants > 366.
     </p>
    <h3>Matching problems</h3>
    <p>If you have 5 red balls and 5 blue balls in 9 boxes, whatever arrangement, at least one box has at least 2 balls.</p>
    <p>More generally, distributing n items into k catagories forces at least $$
      \left\lceil \frac{n}{k} \right\rceil
      $$ items in one catagory.</p>
    <h3>Why this simple idea matters</h3>
    <li><strong>Universality.</strong> Any time you try to squeeze more objects into fewer ‚Äúslots,‚Äù you get overlap.</li>
    <li><strong>Certainty.</strong> Unlike probabilistic arguments, PHP yields a strict, deterministic guarantee.</li>
    <li><strong>Foundation.</strong> Many elementary proofs (e.g., in combinatorics, graph theory, and number theory) rest on pigeonholes.</li>
  </section>

  <section id="infinite">
    <h2>2. Going Deeper‚ÄîInfinite Applications</h2>
    <p> While the finite PHP is easy, there are <strong>‚Äúinfinite‚Äù</strong> analogues that let you extract surprising conclusions from seemingly weak assumptions.</p>.
    <h3> Infinite Pigeonhole Principle</h3>
    <p><strong>Infinite Pigeonhole Principle (Weak form)</strong>If infinitely many objects (pigeons) are distributed among finitely many categories (holes), then at least one category must contain infinitely many objects.</p>
    <p><strong>Why.</strong> Suppose you have infinitely many items x1, x2, x3,... and only m catagories. If each category held only finitely many, say at most Ni in catagory i, then the total objects would be at most N1 + N2 + ... +Nm < ‚àû. That contradicts ‚Äúinfinitely many.‚Äù Hence some category is infinite.</p>
    <p><strong>Diagram 1:</strong></p>
    <div class="viz"><iframe src="bins.html"></iframe></div>
    <h3>Dirichlet‚Äôs Approximation</h3>
    <div class="callout">
      $$\bigl|\alpha - \tfrac{p}{q}\bigr| < \tfrac1{qN},\quad 1\le q\le N$$
    </div>
  </section>

  <section id="cs">
    <h2>3. Pigeonholes in Computer Science</h2>
    <h3>Hashing &amp; Collisions</h3>
    <p>If $n$-bit inputs map to $m$-bit outputs with $n>m$, collisions are forced.</p>
    <div class="viz"><iframe src="hash.html"></iframe></div>
    <h3>Compression Paradox</h3>
    <div class="callout">
      $$2^0+2^1+\dots+2^{L-1}=2^L-1$$
    </div>
  </section>

  <section id="proofs">
    <h2>4. Surprising Proofs</h2>
    <h3>Erd≈ës‚ÄìSzekeres</h3>
    <p>Sequence length $mn+1$ ‚áí inc.\ subseq.\ $m+1$ or dec.\ $n+1$.</p>
    <div class="viz"><iframe src="grid.html"></iframe></div>
    <h3>Ramsey in $K_6$</h3>
    <div class="viz"><iframe src="star.html"></iframe></div>
  </section>

  <section id="art">
    <h2>5. The Art of Finding the Right Pigeonholes</h2>
    <p>Map objects ‚Üí categories creatively: intervals, residues, colors, chain lengths.</p>
  </section>

  <section id="closing">
    <h2>Closing</h2>
    <p>From socks to cryptography, PHP is your lens on infinity and inevitability.</p>
    <blockquote>Call to action: Next time you see ‚Äúmore objects than categories,‚Äù pause‚Äîdefine your holes wisely.</blockquote>
  </section>

</body>
</html>
